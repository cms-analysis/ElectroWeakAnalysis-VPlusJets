/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "RooPowerExpPdf.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 

ClassImp(RooPowerExpPdf) 

 RooPowerExpPdf::RooPowerExpPdf(const char *name, const char *title, 
                        RooAbsReal& _x,
                        RooAbsReal& _c,
                        RooAbsReal& _power) :
   RooAbsPdf(name,title), 
   x("x","x",this,_x),
   c("c","c",this,_c),
   power("power","power",this,_power)
 { 
 } 


 RooPowerExpPdf::RooPowerExpPdf(const RooPowerExpPdf& other, const char* name) :  
   RooAbsPdf(other,name), 
   x("x",this,other.x),
   c("c",this,other.c),
   power("power",this,other.power)
 { 
 } 



 Double_t RooPowerExpPdf::evaluate() const 
 { 
   // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE 
   return TMath::Power(x,power)*TMath::Exp(c*x) ; 
 } 



 Int_t RooPowerExpPdf::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName) const  
 { 
   // LIST HERE OVER WHICH VARIABLES ANALYTICAL INTEGRATION IS SUPPORTED, 
   // ASSIGN A NUMERIC CODE FOR EACH SUPPORTED (SET OF) PARAMETERS 
   // THE EXAMPLE BELOW ASSIGNS CODE 1 TO INTEGRATION OVER VARIABLE X
   // YOU CAN ALSO IMPLEMENT MORE THAN ONE ANALYTICAL INTEGRAL BY REPEATING THE matchArgs 
   // EXPRESSION MULTIPLE TIMES

   if ((-1*c*x.min(rangeName)> 0) && (matchArgs(allVars,analVars,x)))
     return 1 ; 
   return 0 ; 
 } 

double ExpIntegralE(double p, double x) {

  // std::cout << "ExpIntegralE(" << p << "," << x << ")\n";
  double sum(0.), term(10.);
  int k(0);
  do {
    term = TMath::Exp(k*TMath::Log(x)-TMath::LnGamma(2-p+k));
    sum += term;
    ++k;
    //std::cout << "  term " << k << ": " << term << '\n';
  } while ((TMath::Abs(term/sum) > 1e-9)&&(k<1000));

  double ret(TMath::Gamma(1-p)*(TMath::Power(x, p-1) - TMath::Exp(-x)*sum));
  //std::cout << "returns: " << ret << '\n';
  return ret;
}

double incomplete_gamma(double s, double x) {
  double ret(TMath::Gamma(s, x)*TMath::Gamma(s));
  // std::cout << "incomplete_gamma(" << s << ',' << x << ") = " << ret << '\n';
  return ret;
}

 Double_t RooPowerExpPdf::analyticalIntegral(Int_t code, const char* rangeName) const  
 { 
   // RETURN ANALYTICAL INTEGRAL DEFINED BY RETURN CODE ASSIGNED BY getAnalyticalIntegral
   // THE MEMBER FUNCTION x.min(rangeName) AND x.max(rangeName) WILL RETURN THE INTEGRATION
   // BOUNDARIES FOR EACH OBSERVABLE x

   if (code==1) { 
     double maxTerm = -1*TMath::Power(x.max(rangeName), power+1) * 
       ExpIntegralE(-1*power, -1*c*x.max(rangeName));
     double minTerm = -1*TMath::Power(x.min(rangeName), power+1) * 
       ExpIntegralE(-1*power, -1*c*x.min(rangeName));
     // double maxTerm = -1*incomplete_gamma(power+1, -1*c*x.max(rangeName)) *
     //   TMath::Power(x.max(rangeName), power+1) * 
     //   TMath::Power((-1*c*x.max(rangeName)), -1*power -1);
     // double minTerm = -1*incomplete_gamma(power+1, -1*c*x.min(rangeName)) *
     //   TMath::Power(x.min(rangeName), power+1) * 
     //   TMath::Power((-1*c*x.min(rangeName)), -1*power -1);
     // std::cout << "c " << c << " power " << power << '\n';
     // std::cout << "integral: " << maxTerm << " - " << minTerm << " = " << 
     //   (maxTerm-minTerm) << '\n';
     return (maxTerm-minTerm) ; 
   } 
   return 0 ; 
 }
